from scapy.all import sniff, rdpcap, IP, TCP #import scapy modules
import time #import time module to take care of  time lapse
import logging #logging module, allowing you to track events, debug issues, and store alerts

# Set up logging
logging.basicConfig(filename="dos_alerts.log", level=logging.INFO) #sets up logging for your script, meaning all INFO-level messages (including alerts) will be stored in the "dos_alerts.log"

syn_total = 0 #initialize global variable syn_count to 0. syn_count is used to count the number of SYN packets.
start_time = time.time() #save current time into start_time variable.This is also a global variable.

# Fixed Thresholds
THRESHOLD = 20  # Adjust based on expected traffic

def detect_dos(packet): #define a function named detect_syn(), takes packet as an argument
    global syn_total, start_time # declare global variables
    #print("analyzed packet: ")
    # Ensure packet has both IP and TCP layers and SYN packet is set
    if packet.haslayer(IP) and packet.haslayer(TCP) and packet[TCP].flags == "S": 
        syn_total += 1  # Track total SYN packets globally
        print("syncount: ", syn_total) #print total # of SYN packets encountered so far

    if time.time() - start_time >= 1: # This line checks if at least 1 second has passed since the last reset (start_time). If so, it prints the number of detected SYN packets per second
        print(f"SYN packets detected: {syn_total}/sec")
        if syn_total > THRESHOLD:  #if total # of SYN packets per sec is > the threshold, print and log the alert message
            alert_msg = f"üö® Possible DDoS attack detected! Total SYN packets/sec: {syn_total} (Threshold: {THRESHOLD})"
            print(alert_msg)
            logging.info(alert_msg)

            # Suggested Snort Rule
            timestamp=time.time()
            print(timestamp)
            # Alert if SYN flood threshold is exceeded. Monitors TCP SYN packets from any source to the home network.
# Targets packets with SYN flag set (potential flood attempts).Triggers an alert if an IP sends more than 20 SYN packets in 1 second.
#sid:1000001 ‚Üí Unique rule identifier.rev:1 ‚Üí Revision number for the rule.
            snort_rule = f'alert tcp any any -> $HOME_NET any (flags:S; msg:"Possible DDoS attack detected"; threshold: type threshold, count {syn_total}, seconds 1; sid:2000001; rev:1;)'
            print(f"üîç Suggested Snort Rule:\n{snort_rule}")

            # Suggested UFW Rule (Blocking excessive SYN traffic)
            ufw_rule = "sudo ufw deny proto tcp from {packet[IP].src}"
            print(f"üõ°Ô∏è Suggested UFW Rule:\n{ufw_rule}")

        # Reset counter and timer
        syn_total = 0
        start_time = time.time()
def analyze_pcap(file_path): #define a function to start analyzing a pcap file
#    print("fun:", file_path) 
    packets = rdpcap(file_path) #Reads a PCAP file using rdpcap(file_path), loading all packets into a list.
    for packet in packets: #Loops through each packet from the PCAP file. Calls detect_syn(packet) to analyze each packet individually for SYN flood detection
        detect_dos(packet) 

def start_live_capture(): # define a function to start sniffing on live packet capture
    sniff(filter="tcp", prn=detect_dos, store=0) # Captures only TCP packets.
#prn=detect_dos ‚Üí Calls detect_syn() function for each packet to analyze SYN floods.
#store=0 ‚Üí Prevents storing packets in memory (same as store=False for efficiency).

# Choose mode: PCAP file analysis or live capture
mode = input("Enter mode (pcap/live): ").strip().lower() #strip the whitespaces from the mode selected and convert into lowercase
if mode == "pcap": #if pcap, then enter filepath for the pcap file to be analyzed
    file_path = input("Enter PCAP file path: ").strip()
    print("ready to analyze: ", file_path)
    analyze_pcap(file_path) # calling analyze_pcap(file_path) function
elif mode == "live": #calling start_live_capture() function if mode selected is "live"
    start_live_capture()
else:
    print("Invalid mode! Choose 'pcap' or 'live'.") #choose either pcap or live or its an invalid mode

